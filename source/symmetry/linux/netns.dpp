//#include <stdio.h>
//#include <string.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>
#include <net/if.h>
#include <stdarg.h>
//#include <stdlib.h>
//#include <errno.h>
//#include <fcntl.h>
//#include <unistd.h>
//#include <netinet/in.h>
//#include <arpa/inet.h>
//#include <sys/ioctl.h>
//#include "util.h"
#include <netlink/socket.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

enum MAX_PAYLOAD = 1024;

struct nl_req {
    nlmsghdr n;
    ifinfomsg i;
    char[MAX_PAYLOAD] buf;
};

auto NLMSG_TAIL(T)(T nmsg)
{
	return (cast (rtattr *) ((cast(void *) (nmsg)) + NLMSG_ALIGN((nmsg).nlmsg_len)));
}

void addattr_l(nlmsghdr* n, int maxlen, ushort type, const void* data, ushort datalen)
{
	import std.exception : enforce;
	import std.format : format;
	import core.stdc.string : memcpy;

    // C version : ushort attr_len = RTA_LENGTH(datalen);
    ushort attr_len = cast(ushort)(( (  rtattr.sizeof + 4U - 1 ) & ~ ( 4U - 1 ) ) +  datalen);
    // C version : uint newlen = NLMSG_ALIGN(n.nlmsg_len) + RTA_ALIGN(attr_len);
    uint newlen = (( n.nlmsg_len + 4U - 1 ) & ~ (4U - 1) ) + ( ( attr_len + 4U - 1 ) & ~ ( 4U - 1 ));

    enforce(newlen <= maxlen, format!"cannot add attribute. size (%d) exceeded maxlen (%d)\n"
            (newlen, maxlen));

    rtattr *rta;
    rta = NLMSG_TAIL(n);
    rta.rta_type = type;
    rta.rta_len = attr_len;
    if (datalen)
        memcpy(RTA_DATA(rta), data, datalen);

    n.nlmsg_len = newlen;
}

rtattr* addattr_nest(nlmsghdr* n, int maxlen, ushort type)
{
    rtattr* nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, null, 0);
    return nest;
}

void addattr_nest_end(nlmsghdr *n, rtattr *nest)
{
    nest.rta_len = cast(ushort)(cast(void *)NLMSG_TAIL(n) - cast(void *)nest);
}

// string
auto readResponse(int fd, msghdr* msg, char* response)
{
	import core.stdc.string : strerror;
	import std.exception : enforce;
	import std.string : fromStringz;

    iovec* iov = msg.msg_iov;
    iov.iov_base = cast(void*) *response;
    iov.iov_len = MAX_PAYLOAD;

    ptrdiff_t resp_len = recvmsg(fd, msg, 0);
/+
    enforce(resp_len != 0, "EOF on netlink");
	enforce(resp_len > 0, format!"netlink receive error: %s(%s)"(strerr(errno).fromStringz,errno));
+/
    return resp_len;
}

void checkResponse(int sock_fd)
{
	import core.stdc.string : strerror;
	import std.exception : enforce;
	import std.string : fromStringz;
	import std.exception : enforce;
	import std.format : format;
	import core.stdc.stdlib : free, malloc;

    iovec iov;
    msghdr msg = {
            msg_name : null,
            msg_namelen : 0,
            msg_iov : &iov,
            msg_iovlen : 1,
    };
    void* resp = malloc(MAX_PAYLOAD);

    ssize_t resp_len = readResponse(sock_fd, &msg, cast(char*) &resp);

    nlmsghdr *hdr = cast (nlmsghdr*) resp;
    int nlmsglen = hdr.nlmsg_len;
    int datalen = cast(int)(nlmsglen - (*hdr).sizeof);

    // Did we read all data?
    if (datalen < 0 || nlmsglen > resp_len) {
        enforce(!(msg.msg_flags & MSG_TRUNC),"received truncated message");
        enforce(false,format!"malformed message: nlmsg_len=%d"(nlmsglen));
    }

    // Was there an error?
    if (hdr.nlmsg_type == NLMSG_ERROR) {
        nlmsgerr *err = cast(nlmsgerr*) NLMSG_DATA(hdr);

        if (datalen < nlmsgerr.sizeof)
            fprintf(stderr, "ERROR truncated!\n");

        if(err.error) {
            errno = -err.error;
            enforce(false,format!"RTNETLINK: %s(%s)"(strerror(errno).fromStringz,errno));
        }
    }

    free(resp);
}

/+
int createSocket(int domain, int type, int protocol)
{
	import core.stdc.string : strerror;
	import std.string : fromStringz;
	import std.exception : enforce;	

    int sock_fd = socket(domain, type, protocol);
    enforce(sock_fd >= 0, format!"cannot open socket: %s(%s)"(strerror(errno).fromStringz,errno));

    return sock_fd;
}

void send_nlmsg(int sock_fd, nlmsghdr* n)
{
	import core.stdc.string : strerror;
	import std.string : fromStringz;
	import std.exception : enforce;	

    iovec iov = {
            iov_base = n,
            iov_len = n.nlmsg_len
    };

    msghdr msg = {
            msg_name = null,
            msg_namelen = 0,
            msg_iov = &iov,
            msg_iovlen = 1
    };

    n.nlmsg_seq++;

    ssize_t status = sendmsg(sock_fd, &msg, 0);
    enforce(status >= 0, format!"cannot talk to rtnetlink: %s(%s)"(strerror(errno).fromStringz,errno));

    check_response(sock_fd);
}

int get_netns_fd(int pid)
{
	import core.stdc.string : strerror;
	import std.string : fromStringz;
	import std.exception : enforce;	

    char[256] path;
    sprintf(path, "/proc/%d/ns/net", pid);

    int fd = open(path, O_RDONLY);

    enforce(fd >= 0, format!"cannot read netns file %s: %s(%s)"(path,strerror(errno).fromStringz,errno));

    return fd;
}

void ifUp(string interfaceName, string ip, string netMask)
{
	import core.stdc.string : strerror;
	import std.string : fromStringz;
	import std.exception : enforce;	
	import core.stdc.string : memcpy;

    int sock_fd = createSocket(PF_INET, SOCK_DGRAM, IPPROTO_IP);

    ifreq ifr;
    memset(&ifr, 0, ifreq.sizeof);
    strncpy(ifr.ifr_name, interfaceName.toStringz, interfaceName.length);

    sockaddr_in saddr;
    memset(&saddr, 0, sockaddr_in.sizeof);
    saddr.sin_family = AF_INET;
    saddr.sin_port = 0;

    char *p = cast (char *) &saddr;

    saddr.sin_addr.s_addr = inet_addr(ip.toStringz);
    memcpy((cast(char *)&(ifr.ifr_addr)), p, sockaddr.sizeof);
    enforce(!ioctl(sock_fd, SIOCSIFADDR, &ifr),
        format!"cannot set ip addr %s, %s: %s"(ifname, ip,strerror(errno).fromStringz,errno));

    saddr.sin_addr.s_addr = inet_addr(netmask);
    memcpy((cast(char *)&(ifr.ifr_addr)), p, sockaddr.sizeof);
    enforce(!ioctl(sock_fd, SIOCSIFNETMASK, &ifr),
        format!"cannot set netmask for addr %s, %s: %s(%s)"(ifname, netmask,strerror(errno).fromStringz,errno));

    ifr.ifr_flags |= IFF_UP | IFF_BROADCAST | IFF_RUNNING | IFF_MULTICAST;
    enforce(!ioctl(sock_fd, SIOCSIFFLAGS, &ifr),
        format!"cannot set flags for addr %s, %s: %s(%s)"(ifname, ip,strerror(errno).fromStringz,errno));

    close(sock_fd);
}

#include <netlink/socket.h>

// ip link add ifname type veth ifname name peername
void createVeth(int sock_fd, string interfaceName, string peerName)
{
    ushort flags =
            NLM_F_REQUEST  // This is a request message
            | NLM_F_CREATE // Create the device if it doesn't exist
            | NLM_F_EXCL   // If it already exists, do nothing
            | NLM_F_ACK;   // Reply with an acknowledgement or error

	nlmsg_hdr n = {
            //n.nlmsg_len : NLMSG_LENGTH(ifinfomsg.sizeof),
			nlmsg_len : ( ifinfomsg.sizeof + (cast(int) ( ( nlmsghdr.sizeof + 4U - 1 ) & ~ ( 4U - 1 ) ) ) ),
			nlmsg_flags : flags,
            nlmsg_type : RTM_NEWLINK, // This is a netlink message
	};

	ifinfomsg i = {
		ifi_family : PF_NETLINK,
	};

    // Initialise request message.
    nl_req req = {
			n : n,
            i : i,
    };

    nlmsghdr* n = &req.n;
    int maxlen = req.sizeof;

    /*
     * Create an attribute r0 with the veth info. e.g if ifname is veth0
     * then the following will be appended to the message
     * {
     *   rta_type: IFLA_IFNAME
     *   rta_len: 5 (len(veth0) + 1)
     *   data: veth0\0
     * }
     */
    addattr_l(n, maxlen, IFLA_IFNAME, interfaceName.toStringz, interfaceName.length + 1);

    // Add a nested attribute r1 within r0 containing iface info
    rtattr *linfo = addattr_nest(n, maxlen, IFLA_LINKINFO);
    // Specify the device type is veth
    addattr_l(&req.n, req.sizeof, IFLA_INFO_KIND, "veth", 5);

    // Add another nested attribute r2
    rtattr *linfodata = addattr_nest(n, maxlen, IFLA_INFO_DATA);

    // This next nested attribute r3 one contains the peer name e.g veth1
    rtattr *peerinfo = addattr_nest(n, maxlen, VETH_INFO_PEER);
    n.nlmsg_len += ifinfomsg.sizeof;
    addattr_l(n, maxlen, IFLA_IFNAME, peerName.toStringz, peername.toStringz + 1);
    addattr_nest_end(n, peerinfo); // end r3 nest

    addattr_nest_end(n, linfodata); // end r2 nest
    addattr_nest_end(n, linfo); // end r1 nest

    // Send the message
    send_nlmsg(sock_fd, n);
}

/// $ ip link set veth1 netns coke
void moveInterfaceToPidNetNS(int sock_fd, string interfaceName, int netns)
{
	nlmsg_hdf n = {
            nlmsg_len : ( ( ifinfomsg.sizeof ) + ( cast( int ) ( ( ( ( nlmsghdr ) .sizeof ) + 4U - 1 ) & ~ ( 4U - 1 ) ) ) ),
            nlmsg_flags : 0x01 | 0x04,
            nlmsg_type : RTM_NEWLINK,
    };

	ifinfomsg i = {
            ifi_family : 16,
    };

    nl_req req = {
            n : n,
			i : i,
    };

    addattr_l(&req.n, req.sizeof, IFLA_NET_NS_FD, &netns, 4);
    addattr_l(&req.n, req.sizeof, IFLA_IFNAME, interfaceName.toStringz, interfaceName.length+1);
    send_nlmsg(sock_fd, &req.n);
}

void prepareNetNS(int childPID)
{
    string veth = "veth0";
    string vpeer = "veth1";
    string veth_addr = "10.1.1.1";
    string vpeer_addr = "10.1.1.2";
    string netmask = "255.255.255.0";

    // Create our netlink socket
    int sock_fd = createSocket( PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);

    // ... and our veth pair veth0 <=> veth1.
    createVeth(sock_fd, veth, vpeer);

    // veth0 is in our current (initial) namespace
    // so we can bring it up immediately.
    ifUp(veth, veth_addr, netmask);

    // ... veth1 will be moved to the command namespace.
    // To do that though we need to grab a file descriptor
    // to and enter the commands namespace but first we must
    // remember our current namespace so we can get back to it
    // when we're done.
    int mynetns = get_netns_fd(getpid());
    int child_netns = get_netns_fd(childPID);

    // Move veth1 to the command network namespace.
    move_if_to_pid_netns(sock_fd, vpeer, child_netns);

    // ... then enter it
    enforce(!setns(child_netns, CLONE_NEWNET),format!"cannot setns for child at pid %d: %s(%s)"(childPID,strerror(errno).fromStringz,errno));
    }

    // ... and bring veth1 up
    ifUp(vpeer, vpeer_addr, netmask);

    // ... before moving back to our initial network namespace.
		enforce(!setns(mynetns, CLONE_NEWNET),format!"cannot restore previous netns: %s"(strerror(errno).fromStringz,errno));
    }

    close(sock_fd);
}
+/

