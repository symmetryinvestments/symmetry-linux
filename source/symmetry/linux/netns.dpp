//#include <stdio.h>
//#include <string.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>
#include <net/if.h>
//#include <stdlib.h>
//#include <errno.h>
//#include <fcntl.h>
//#include <unistd.h>
//#include <netinet/in.h>
//#include <arpa/inet.h>
//#include <sys/ioctl.h>
//#include "util.h"
#include <netlink/socket.h>
#include <stdio.h>
#include <string.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>
#include <net/if.h>
#include <stdarg.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>

#define MAX_PAYLOAD 1024

struct nl_req {
    struct nlmsghdr n;
    struct ifinfomsg i;
    char buf[MAX_PAYLOAD];
};

#define NLMSG_TAIL(nmsg) \
	((struct rtattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

void addattr_l(nlmsghdr* n, int maxlen, ushort type, const void* data, ushort datalen)
{
    __u16 attr_len = RTA_LENGTH(datalen);

    __u32 newlen = NLMSG_ALIGN(n.nlmsg_len) + RTA_ALIGN(attr_len);
    if (newlen > maxlen)
        die("cannot add attribute. size (%d) exceeded maxlen (%d)\n",
            newlen, maxlen);

    rtattr *rta;
    rta = NLMSG_TAIL(n);
    rta.rta_type = type;
    rta.rta_len = attr_len;
    if (datalen)
        memcpy(RTA_DATA(rta), data, datalen);

    n.nlmsg_len = newlen;
}

rtattr* addattr_nest(nlmsghdr* n, int maxlen, ushort type)
{
    rtattr* nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, null, 0);
    return nest;
}

void addattr_nest_end(nlmsghdr *n, rtattr *nest)
{
    nest.rta_len = cast(void *)NLMSG_TAIL(n) - cast(void *)nest;
}

string readResponse(int fd, msghdr* msg)
{
    iovec *iov = msg.msg_iov;
    iov.iov_base = *response;
    iov.iov_len = MAX_PAYLOAD;

    ssize_t resp_len = recvmsg(fd, msg, 0);

    if (resp_len == 0)
        die("EOF on netlink\n");

    if (resp_len < 0)
        die("netlink receive error: %m\n");

    return resp_len;
}

void checkResponse(int sock_fd)
{
    iovec iov;
    msghdr msg = {
            msg_name : null,
            msg_namelen : 0,
            msg_iov : &iov,
            msg_iovlen : 1,
    };
    char *resp = malloc(MAX_PAYLOAD);

    ssize_t resp_len = readResponse(sock_fd, &msg, &resp);

    nlmsghdr *hdr = cast (nlmsghdr*) resp;
    int nlmsglen = hdr.nlmsg_len;
    int datalen = nlmsglen - sizeof(*hdr);

    // Did we read all data?
    if (datalen < 0 || nlmsglen > resp_len) {
        if (msg.msg_flags & MSG_TRUNC)
            die("received truncated message\n");

        die("malformed message: nlmsg_len=%d\n", nlmsglen);
    }

    // Was there an error?
    if (hdr.nlmsg_type == NLMSG_ERROR) {
        nlmsgerr *err = cast(nlmsgerr*) NLMSG_DATA(hdr);

        if (datalen < nlmsgerr.sizeof)
            fprintf(stderr, "ERROR truncated!\n");

        if(err.error) {
            errno = -err.error;
            die("RTNETLINK: %m\n");
        }
    }

    free(resp);
}

int createSocket(int domain, int type, int protocol)
{
    int sock_fd = socket(domain, type, protocol);
    if (sock_fd < 0)
        die("cannot open socket: %m\n");

    return sock_fd;
}

void send_nlmsg(int sock_fd, nlmsghdr* n)
{
    iovec iov = {
            .iov_base = n,
            .iov_len = n.nlmsg_len
    };

    msghdr msg = {
            .msg_name = null,
            .msg_namelen = 0,
            .msg_iov = &iov,
            .msg_iovlen = 1
    };

    n.nlmsg_seq++;

    ssize_t status = sendmsg(sock_fd, &msg, 0);
    if (status < 0)
        die("cannot talk to rtnetlink: %m\n");

    check_response(sock_fd);
}

int get_netns_fd(int pid)
{
    char path[256];
    sprintf(path, "/proc/%d/ns/net", pid);

    int fd = open(path, O_RDONLY);

    if (fd < 0)
        die("cannot read netns file %s: %m\n", path);

    return fd;
}

void if_up(string interfaceName, string ip, string netMask)
{
    int sock_fd = createSocket(PF_INET, SOCK_DGRAM, IPPROTO_IP);

    ifreq ifr;
    memset(&ifr, 0, ifreq.sizeof);
    strncpy(ifr.ifr_name, interfaceName.toStringz, interfaceName.length);

    sockaddr_in saddr;
    memset(&saddr, 0, sockaddr_in.sizeof);
    saddr.sin_family = AF_INET;
    saddr.sin_port = 0;

    char *p = cast (char *) &saddr;

    saddr.sin_addr.s_addr = inet_addr(ip.toStringz);
    memcpy(((char *)&(ifr.ifr_addr)), p, sockaddr.sizeof);
    if (ioctl(sock_fd, SIOCSIFADDR, &ifr))
        die("cannot set ip addr %s, %s: %m\n", ifname, ip);

    saddr.sin_addr.s_addr = inet_addr(netmask);
    memcpy((cast(char *)&(ifr.ifr_addr)), p, sockaddr.sizeof);
    if (ioctl(sock_fd, SIOCSIFNETMASK, &ifr))
        die("cannot set netmask for addr %s, %s: %m\n", ifname, netmask);

    ifr.ifr_flags |= IFF_UP | IFF_BROADCAST | IFF_RUNNING | IFF_MULTICAST;
    if (ioctl(sock_fd, SIOCSIFFLAGS, &ifr))
        die("cannot set flags for addr %s, %s: %m\n", ifname, ip);

    close(sock_fd);
}

#include <netlink/socket.h>

// ip link add ifname type veth ifname name peername
void createVeth(int sock_fd, string interfaceName, string peerName)
{
    ushort flags =
            NLM_F_REQUEST  // This is a request message
            | NLM_F_CREATE // Create the device if it doesn't exist
            | NLM_F_EXCL   // If it already exists, do nothing
            | NLM_F_ACK;   // Reply with an acknowledgement or error

    // Initialise request message.
    nl_req req = {
            n.nlmsg_len : NLMSG_LENGTH(ifinfomsg.sizeof),
            n.nlmsg_flags : flags,
            n.nlmsg_type : RTM_NEWLINK, // This is a netlink message
            i.ifi_family : PF_NETLINK,
    };

    nlmsghdr* n = &req.n;
    int maxlen = req.sizeof;

    /*
     * Create an attribute r0 with the veth info. e.g if ifname is veth0
     * then the following will be appended to the message
     * {
     *   rta_type: IFLA_IFNAME
     *   rta_len: 5 (len(veth0) + 1)
     *   data: veth0\0
     * }
     */
    addattr_l(n, maxlen, IFLA_IFNAME, interfaceName.toStringz, interfaceName.length + 1);

    // Add a nested attribute r1 within r0 containing iface info
    rtattr *linfo = addattr_nest(n, maxlen, IFLA_LINKINFO);
    // Specify the device type is veth
    addattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, "veth", 5);

    // Add another nested attribute r2
    rtattr *linfodata = addattr_nest(n, maxlen, IFLA_INFO_DATA);

    // This next nested attribute r3 one contains the peer name e.g veth1
    rtattr *peerinfo = addattr_nest(n, maxlen, VETH_INFO_PEER);
    n.nlmsg_len += ifinfomsg.sizeof;
    addattr_l(n, maxlen, IFLA_IFNAME, peerName.toStringz, peername.toStringz + 1);
    addattr_nest_end(n, peerinfo); // end r3 nest

    addattr_nest_end(n, linfodata); // end r2 nest
    addattr_nest_end(n, linfo); // end r1 nest

    // Send the message
    send_nlmsg(sock_fd, n);
}

/// $ ip link set veth1 netns coke
void moveInterfaceToPidNetNS(int sock_fd, string interfaceName, int netns)
{
    nl_req req = {
            n.nlmsg_len : NLMSG_LENGTH(ifinfomsg.sizeof),
            n.nlmsg_flags : NLM_F_REQUEST | NLM_F_ACK,
            n.nlmsg_type : RTM_NEWLINK,
            i.ifi_family : PF_NETLINK,
    };

    addattr_l(&req.n, req.sizeof, IFLA_NET_NS_FD, &netns, 4);
    addattr_l(&req.n, req.sizeof, IFLA_IFNAME, interfaceName.toStringz, interfaceName.length+1);
    send_nlmsg(sock_fd, &req.n);
}

void prepareNetNS(int childPID)
{
    char *veth = "veth0";
    char *vpeer = "veth1";
    char *veth_addr = "10.1.1.1";
    char *vpeer_addr = "10.1.1.2";
    char *netmask = "255.255.255.0";

    // Create our netlink socket
    int sock_fd = createSocket( PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);

    // ... and our veth pair veth0 <=> veth1.
    createVeth(sock_fd, veth, vpeer);

    // veth0 is in our current (initial) namespace
    // so we can bring it up immediately.
    if_up(veth, veth_addr, netmask);

    // ... veth1 will be moved to the command namespace.
    // To do that though we need to grab a file descriptor
    // to and enter the commands namespace but first we must
    // remember our current namespace so we can get back to it
    // when we're done.
    int mynetns = get_netns_fd(getpid());
    int child_netns = get_netns_fd(childPID);

    // Move veth1 to the command network namespace.
    move_if_to_pid_netns(sock_fd, vpeer, child_netns);

    // ... then enter it
    if (setns(child_netns, CLONE_NEWNET)) {
        die("cannot setns for child at pid %d: %m\n", childPID);
    }

    // ... and bring veth1 up
    if_up(vpeer, vpeer_addr, netmask);

    // ... before moving back to our initial network namespace.
    if (setns(mynetns, CLONE_NEWNET)) {
        die("cannot restore previous netns: %m\n");
    }

    close(sock_fd);
}


